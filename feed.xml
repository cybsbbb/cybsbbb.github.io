<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://cybsbbb.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://cybsbbb.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-11-15T06:38:59+00:00</updated><id>https://cybsbbb.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">A Python implementation of Kd-Tree and K-nearest neighbors search</title><link href="https://cybsbbb.github.io/blog/2024/kd-tree/" rel="alternate" type="text/html" title="A Python implementation of Kd-Tree and K-nearest neighbors search"/><published>2024-01-04T04:28:19+00:00</published><updated>2024-01-04T04:28:19+00:00</updated><id>https://cybsbbb.github.io/blog/2024/kd-tree</id><content type="html" xml:base="https://cybsbbb.github.io/blog/2024/kd-tree/"><![CDATA[<p>Because python does not have the build-in n-partition function. For now, I sort each layer, which make the code a little bit slower but is enough to pass the test cases in most cases.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">sys</span>
<span class="kn">import</span> <span class="n">math</span>
<span class="kn">import</span> <span class="n">heapq</span>
<span class="nb">input</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="n">readline</span>


<span class="k">class</span> <span class="nc">k_d_tree</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">d</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">self</span><span class="p">.</span><span class="n">n</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">tree</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">n</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">build_tree</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">build_tree</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">dimension</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">%</span> <span class="n">self</span><span class="p">.</span><span class="n">d</span>
        <span class="n">points</span><span class="p">[</span><span class="n">left</span><span class="p">:</span> <span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">left</span><span class="p">:</span> <span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">X</span><span class="p">:</span> <span class="n">X</span><span class="p">[</span><span class="n">dimension</span><span class="p">])</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">self</span><span class="p">.</span><span class="n">tree</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">build_tree</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">build_tree</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">query_point</span><span class="p">,</span> <span class="n">heap</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">dimension</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">%</span> <span class="n">self</span><span class="p">.</span><span class="n">d</span>
        <span class="c1"># mid
</span>        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">mid_dist</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">((</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">query_point</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">tree</span><span class="p">[</span><span class="n">mid</span><span class="p">]))</span>
        <span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="o">-</span><span class="n">mid_dist</span><span class="p">)</span>
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">:</span>
            <span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
        <span class="c1"># left
</span>        <span class="k">if</span> <span class="n">query_point</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">self</span><span class="p">.</span><span class="n">tree</span><span class="p">[</span><span class="n">mid</span><span class="p">][</span><span class="n">dimension</span><span class="p">]:</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">query</span><span class="p">(</span><span class="n">query_point</span><span class="p">,</span> <span class="n">heap</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="ow">or</span> <span class="p">(</span><span class="n">query_point</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">-</span> <span class="n">self</span><span class="p">.</span><span class="n">tree</span><span class="p">[</span><span class="n">mid</span><span class="p">][</span><span class="n">dimension</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">self</span><span class="p">.</span><span class="nf">query</span><span class="p">(</span><span class="n">query_point</span><span class="p">,</span> <span class="n">heap</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
        <span class="c1"># right
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">query</span><span class="p">(</span><span class="n">query_point</span><span class="p">,</span> <span class="n">heap</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="ow">or</span> <span class="p">(</span><span class="n">query_point</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span> <span class="o">-</span> <span class="n">self</span><span class="p">.</span><span class="n">tree</span><span class="p">[</span><span class="n">mid</span><span class="p">][</span><span class="n">dimension</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">self</span><span class="p">.</span><span class="nf">query</span><span class="p">(</span><span class="n">query_point</span><span class="p">,</span> <span class="n">heap</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>


<span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">()))</span>
<span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">point</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">()))</span>
    <span class="n">points</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>

<span class="n">tree</span> <span class="o">=</span> <span class="nf">k_d_tree</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

<span class="n">q</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="n">query</span> <span class="o">=</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">()</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">query</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">query_point</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">query</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="n">heap</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">tree</span><span class="p">.</span><span class="nf">query</span><span class="p">(</span><span class="n">query_point</span><span class="p">,</span> <span class="n">heap</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

</code></pre></div></div>]]></content><author><name></name></author><category term="algorithm"/><category term="algorithm"/><summary type="html"><![CDATA[Because python does not have the build-in n-partition function. For now, I sort each layer, which make the code a little bit slower but is enough to pass the test cases in most cases.]]></summary></entry><entry><title type="html">A Python implementation of Fenwick Tree (Binary Index Tree)</title><link href="https://cybsbbb.github.io/blog/2024/fenwick-tree/" rel="alternate" type="text/html" title="A Python implementation of Fenwick Tree (Binary Index Tree)"/><published>2024-01-03T04:28:19+00:00</published><updated>2024-01-03T04:28:19+00:00</updated><id>https://cybsbbb.github.io/blog/2024/fenwick-tree</id><content type="html" xml:base="https://cybsbbb.github.io/blog/2024/fenwick-tree/"><![CDATA[<p>There is a good tutorial about the Fenwick Tree (Binary Index Tree); here is the link <a href="https://en.oi-wiki.org/ds/fenwick/">https://en.oi-wiki.org/ds/fenwick/</a>.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span>
<span class="n">fenwick</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">lowbit</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">x</span>

<span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">fenwick</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="n">d</span>
        <span class="n">index</span> <span class="o">+=</span> <span class="nf">lowbit</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">getsum</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">+=</span> <span class="n">fenwick</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="n">index</span> <span class="o">-=</span> <span class="nf">lowbit</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="algorithm"/><category term="algorithm"/><summary type="html"><![CDATA[There is a good tutorial about the Fenwick Tree (Binary Index Tree); here is the link https://en.oi-wiki.org/ds/fenwick/.]]></summary></entry><entry><title type="html">A Python implementation of Segment Tree with range updates and lazy propagation</title><link href="https://cybsbbb.github.io/blog/2024/segment-tree/" rel="alternate" type="text/html" title="A Python implementation of Segment Tree with range updates and lazy propagation"/><published>2024-01-02T04:28:19+00:00</published><updated>2024-01-02T04:28:19+00:00</updated><id>https://cybsbbb.github.io/blog/2024/segment-tree</id><content type="html" xml:base="https://cybsbbb.github.io/blog/2024/segment-tree/"><![CDATA[<p>There is a good tutorial about the SegTree on Codeforce; here is the link: <a href="https://codeforces.com/blog/entry/18051">https://codeforces.com/blog/entry/18051</a>. My code highly relies on it.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SegTree</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">update_func</span><span class="p">,</span> <span class="n">query_func</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="n">self</span><span class="p">.</span><span class="n">h</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">self</span><span class="p">.</span><span class="n">h</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">h</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">self</span><span class="p">.</span><span class="n">update_func</span> <span class="o">=</span> <span class="n">update_func</span>
        <span class="n">self</span><span class="p">.</span><span class="n">query_func</span> <span class="o">=</span> <span class="n">query_func</span>
        <span class="n">self</span><span class="p">.</span><span class="n">tree</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">n</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">lazy</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">n</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_apply</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">tree</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">update_func</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">tree</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">self</span><span class="p">.</span><span class="n">n</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">lazy</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">update_func</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">lazy</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_pull</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="k">while</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
            <span class="n">self</span><span class="p">.</span><span class="n">tree</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">query_func</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">tree</span><span class="p">[</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">tree</span><span class="p">[</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">self</span><span class="p">.</span><span class="n">tree</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">update_func</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">tree</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">lazy</span><span class="p">[</span><span class="n">p</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_push</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">p</span> <span class="o">&gt;&gt;</span> <span class="n">s</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">lazy</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">self</span><span class="p">.</span><span class="nf">_apply</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">lazy</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">self</span><span class="p">.</span><span class="nf">_apply</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">1</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">lazy</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">self</span><span class="p">.</span><span class="n">lazy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">n</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">n</span>
        <span class="n">l0</span><span class="p">,</span> <span class="n">r0</span> <span class="o">=</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span>
        <span class="k">while</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="nf">_apply</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                <span class="n">l</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">r</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">self</span><span class="p">.</span><span class="nf">_apply</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="n">l</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
            <span class="n">r</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">_pull</span><span class="p">(</span><span class="n">l0</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">_pull</span><span class="p">(</span><span class="n">r0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">query_single</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">_push</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">tree</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">n</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">n</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">_push</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">_push</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">query_func</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">tree</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
                <span class="n">l</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">r</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">query_func</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">tree</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
            <span class="n">l</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
            <span class="n">r</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="algorithm"/><category term="algorithm"/><summary type="html"><![CDATA[There is a good tutorial about the SegTree on Codeforce; here is the link: https://codeforces.com/blog/entry/18051. My code highly relies on it.]]></summary></entry></feed>